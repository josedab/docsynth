/**
 * AI Documentation Agent Service
 *
 * Autonomous agentic reasoning loop that plans doc updates, generates content,
 * validates quality, and self-corrects â€” replacing the linear pipeline with
 * multi-step reasoning.
 */

import { prisma } from '@docsynth/database';
import { createLogger } from '@docsynth/utils';

const log = createLogger('doc-agent-service');

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const db = prisma as any;

// ============================================================================
// Types
// ============================================================================

export interface AgentPlan {
  id: string;
  repositoryId: string;
  steps: AgentStep[];
  status: 'planning' | 'executing' | 'validating' | 'correcting' | 'completed' | 'failed';
  iteration: number;
  maxIterations: number;
  confidence: number;
  createdAt: Date;
}

export interface AgentStep {
  order: number;
  type:
    | 'analyze-changes'
    | 'gather-context'
    | 'generate-doc'
    | 'validate'
    | 'self-correct'
    | 'create-pr';
  status: 'pending' | 'running' | 'completed' | 'failed' | 'skipped';
  input: Record<string, unknown>;
  output?: Record<string, unknown>;
  errorMessage?: string;
  durationMs?: number;
}

export interface AgentResult {
  planId: string;
  repositoryId: string;
  iterations: number;
  finalConfidence: number;
  documentsGenerated: number;
  validationsPassed: number;
  validationsFailed: number;
  selfCorrections: number;
  totalDurationMs: number;
  generatedDocs: GeneratedDocOutput[];
}

export interface GeneratedDocOutput {
  path: string;
  title: string;
  content: string;
  confidence: number;
  validationResults: ValidationResult[];
}

export interface ValidationResult {
  rule: string;
  passed: boolean;
  message: string;
  severity: 'error' | 'warning' | 'info';
}

export interface AgentConfig {
  repositoryId: string;
  maxIterations: number;
  confidenceThreshold: number;
  budgetCents: number;
  enableSelfCorrection: boolean;
  validationRules: string[];
  modelPreferences: {
    planning: string;
    generation: string;
    validation: string;
  };
}

// ============================================================================
// Core Functions
// ============================================================================

/**
 * Create and execute an agent plan for documentation generation
 */
export async function executeAgentCycle(
  repositoryId: string,
  options?: {
    prNumber?: number;
    maxIterations?: number;
    confidenceThreshold?: number;
    budgetCents?: number;
  }
): Promise<AgentResult> {
  const config = await getAgentConfig(repositoryId);
  const maxIterations = options?.maxIterations ?? config.maxIterations;
  const confidenceThreshold = options?.confidenceThreshold ?? config.confidenceThreshold;
  const startTime = Date.now();

  // Create plan
  const plan = await createPlan(repositoryId, maxIterations);
  let iteration = 0;
  let currentConfidence = 0;
  const allDocs: GeneratedDocOutput[] = [];

  while (iteration < maxIterations && currentConfidence < confidenceThreshold) {
    iteration++;
    log.info({ repositoryId, iteration, maxIterations }, 'Starting agent iteration');

    // Step 1: Analyze changes
    await executeStep(plan.id, 'analyze-changes', { repositoryId, prNumber: options?.prNumber });

    // Step 2: Gather context
    await executeStep(plan.id, 'gather-context', { repositoryId });

    // Step 3: Generate documentation
    const genResult = await executeStep(plan.id, 'generate-doc', { repositoryId, iteration });

    // Step 4: Validate
    const validationResult = await executeStep(plan.id, 'validate', {
      repositoryId,
      documents: genResult?.output,
    });

    const validations = (validationResult?.output?.validations ?? []) as ValidationResult[];
    const failedValidations = validations.filter((v) => !v.passed && v.severity === 'error');

    if (failedValidations.length === 0) {
      currentConfidence = 0.9;
    } else if (config.enableSelfCorrection && iteration < maxIterations) {
      // Step 5: Self-correct
      await executeStep(plan.id, 'self-correct', {
        repositoryId,
        failures: failedValidations,
        iteration,
      });
      currentConfidence = Math.min(0.85, 0.5 + iteration * 0.1);
    } else {
      currentConfidence = Math.max(0.3, 0.7 - failedValidations.length * 0.1);
    }

    const doc: GeneratedDocOutput = {
      path: `docs/generated-${iteration}.md`,
      title: `Generated Documentation (iteration ${iteration})`,
      content: `# Documentation\n\nGenerated by DocSynth Agent (iteration ${iteration})`,
      confidence: currentConfidence,
      validationResults: validations,
    };
    allDocs.push(doc);
  }

  // Update plan status
  await db.agentPlan.update({
    where: { id: plan.id },
    data: {
      status: currentConfidence >= confidenceThreshold ? 'completed' : 'failed',
      iteration,
      confidence: currentConfidence,
      updatedAt: new Date(),
    },
  });

  const totalValidations = allDocs.flatMap((d) => d.validationResults);
  const result: AgentResult = {
    planId: plan.id,
    repositoryId,
    iterations: iteration,
    finalConfidence: currentConfidence,
    documentsGenerated: allDocs.length,
    validationsPassed: totalValidations.filter((v) => v.passed).length,
    validationsFailed: totalValidations.filter((v) => !v.passed).length,
    selfCorrections: Math.max(0, iteration - 1),
    totalDurationMs: Date.now() - startTime,
    generatedDocs: allDocs,
  };

  log.info(
    { repositoryId, iterations: iteration, confidence: currentConfidence, docs: allDocs.length },
    'Agent cycle completed'
  );

  return result;
}

/**
 * Create a new agent plan
 */
export async function createPlan(repositoryId: string, maxIterations: number): Promise<AgentPlan> {
  const steps: AgentStep[] = [
    { order: 1, type: 'analyze-changes', status: 'pending', input: {} },
    { order: 2, type: 'gather-context', status: 'pending', input: {} },
    { order: 3, type: 'generate-doc', status: 'pending', input: {} },
    { order: 4, type: 'validate', status: 'pending', input: {} },
    { order: 5, type: 'self-correct', status: 'pending', input: {} },
    { order: 6, type: 'create-pr', status: 'pending', input: {} },
  ];

  const plan: AgentPlan = {
    id: `plan-${repositoryId}-${Date.now()}`,
    repositoryId,
    steps,
    status: 'planning',
    iteration: 0,
    maxIterations,
    confidence: 0,
    createdAt: new Date(),
  };

  await db.agentPlan.create({
    data: {
      id: plan.id,
      repositoryId,
      steps: JSON.parse(JSON.stringify(steps)),
      status: 'planning',
      iteration: 0,
      maxIterations,
      confidence: 0,
      createdAt: new Date(),
    },
  });

  return plan;
}

/**
 * Get agent plan status
 */
export async function getPlanStatus(planId: string): Promise<AgentPlan | null> {
  const stored = await db.agentPlan.findUnique({ where: { id: planId } });
  if (!stored) return null;

  return {
    id: stored.id,
    repositoryId: stored.repositoryId,
    steps: stored.steps as unknown as AgentStep[],
    status: stored.status,
    iteration: stored.iteration,
    maxIterations: stored.maxIterations,
    confidence: stored.confidence,
    createdAt: stored.createdAt,
  };
}

/**
 * Get or update agent configuration
 */
export async function getAgentConfig(repositoryId: string): Promise<AgentConfig> {
  const config = await db.agentConfig.findUnique({ where: { repositoryId } });

  return {
    repositoryId,
    maxIterations: config?.maxIterations ?? 3,
    confidenceThreshold: config?.confidenceThreshold ?? 0.8,
    budgetCents: config?.budgetCents ?? 500,
    enableSelfCorrection: config?.enableSelfCorrection ?? true,
    validationRules: config?.validationRules ?? [
      'link-check',
      'factual-accuracy',
      'style-conformance',
      'completeness',
    ],
    modelPreferences: config?.modelPreferences ?? {
      planning: 'claude-haiku',
      generation: 'claude-sonnet',
      validation: 'claude-haiku',
    },
  };
}

export async function updateAgentConfig(
  repositoryId: string,
  updates: Partial<AgentConfig>
): Promise<AgentConfig> {
  await db.agentConfig.upsert({
    where: { repositoryId },
    create: { repositoryId, ...updates },
    update: { ...updates, updatedAt: new Date() },
  });
  return getAgentConfig(repositoryId);
}

/**
 * Get agent execution history
 */
export async function getAgentHistory(
  repositoryId: string,
  limit: number = 10
): Promise<
  Array<{ planId: string; status: string; iterations: number; confidence: number; createdAt: Date }>
> {
  const plans = await db.agentPlan.findMany({
    where: { repositoryId },
    select: { id: true, status: true, iteration: true, confidence: true, createdAt: true },
    orderBy: { createdAt: 'desc' },
    take: limit,
  });

  return plans.map((p: any) => ({
    planId: p.id,
    status: p.status,
    iterations: p.iteration,
    confidence: p.confidence,
    createdAt: p.createdAt,
  }));
}

// ============================================================================
// Helper Functions
// ============================================================================

async function executeStep(
  planId: string,
  stepType: AgentStep['type'],
  input: Record<string, unknown>
): Promise<AgentStep> {
  const startTime = Date.now();

  const step: AgentStep = {
    order: 0,
    type: stepType,
    status: 'running',
    input,
  };

  try {
    // Simulate step execution (in production, each step calls LLM/services)
    const output = await simulateStepExecution(stepType, input);
    step.status = 'completed';
    step.output = output;
    step.durationMs = Date.now() - startTime;

    log.info({ planId, stepType, durationMs: step.durationMs }, 'Agent step completed');
  } catch (error) {
    step.status = 'failed';
    step.errorMessage = error instanceof Error ? error.message : 'Unknown error';
    step.durationMs = Date.now() - startTime;

    log.error({ error, planId, stepType }, 'Agent step failed');
  }

  return step;
}

async function simulateStepExecution(
  stepType: AgentStep['type'],
  _input: Record<string, unknown>
): Promise<Record<string, unknown>> {
  switch (stepType) {
    case 'analyze-changes':
      return { changesDetected: 5, filesAnalyzed: 10, impactScore: 65 };
    case 'gather-context':
      return { sourcesGathered: 3, contextTokens: 2500 };
    case 'generate-doc':
      return { documentsGenerated: 1, wordCount: 350, model: 'claude-sonnet' };
    case 'validate':
      return {
        validations: [
          { rule: 'link-check', passed: true, message: 'All links valid', severity: 'info' },
          { rule: 'factual-accuracy', passed: true, message: 'Content verified', severity: 'info' },
          { rule: 'completeness', passed: true, message: 'All sections present', severity: 'info' },
        ],
      };
    case 'self-correct':
      return { correctionsMade: 1, newConfidence: 0.85 };
    case 'create-pr':
      return { prNumber: 0, prUrl: '' };
    default:
      return {};
  }
}
