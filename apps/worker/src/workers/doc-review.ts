import { createWorker, QUEUE_NAMES, type DocReviewJobData } from '@docsynth/queue';
import { prisma } from '@docsynth/database';
import { GitHubClient } from '@docsynth/github';
import { createLogger } from '@docsynth/utils';

const log = createLogger('doc-review-worker');

export function startDocReviewWorker() {
  const worker = createWorker(
    QUEUE_NAMES.DOC_REVIEW,
    async (job) => {
      const data = job.data as DocReviewJobData;

      log.info({ jobId: job.id, generationJobId: data.generationJobId }, 'Processing doc review');

      await job.updateProgress(10);

      // Get generation job with all related data
      const generationJob = await prisma.generationJob.findUnique({
        where: { id: data.generationJobId },
        include: {
          changeAnalysis: {
            include: {
              prEvent: {
                include: {
                  repository: true,
                },
              },
            },
          },
          docVersions: {
            include: {
              document: true,
            },
          },
        },
      });

      if (!generationJob) {
        throw new Error(`Generation job ${data.generationJobId} not found`);
      }

      await job.updateProgress(30);

      const result = generationJob.result as {
        documents: Array<{
          path: string;
          type: string;
          title: string;
          content: string;
          action: string;
        }>;
        metrics: { totalTokensUsed: number; documentsGenerated: number };
      };

      if (!result?.documents || result.documents.length === 0) {
        // No documents to create PR for
        await prisma.generationJob.update({
          where: { id: data.generationJobId },
          data: {
            status: 'COMPLETED',
            completedAt: new Date(),
          },
        });
        log.info({ generationJobId: data.generationJobId }, 'No documents generated, completing');
        await job.updateProgress(100);
        return;
      }

      await job.updateProgress(50);

      // Create PR with documentation changes
      const repository = generationJob.changeAnalysis.prEvent.repository;
      const [owner, repo] = repository.githubFullName.split('/');
      if (!owner || repo === undefined) {
        throw new Error('Invalid repository name');
      }

      const client = GitHubClient.forInstallation(repository.installationId);

      // Get the default branch SHA
      const baseSha = await client.getLatestCommitSha(owner, repo, repository.defaultBranch);

      // Create a new branch for docs
      const docBranch = `docsynth/pr-${generationJob.changeAnalysis.prEvent.prNumber}-docs`;

      try {
        await client.createBranch(owner, repo, docBranch, baseSha);
      } catch (error: unknown) {
        // Branch might already exist
        if (!(error instanceof Error && error.message?.includes('Reference already exists'))) {
          throw error;
        }
      }

      await job.updateProgress(60);

      // Commit each document
      for (const doc of result.documents) {
        // Check if file exists to get SHA for update
        let existingSha: string | undefined;
        try {
          const existingContent = await client.getFileContent(owner, repo, doc.path, docBranch);
          if (existingContent) {
            // We need to get the blob SHA, but for simplicity we'll use the API
            // that handles this automatically
          }
        } catch {
          // File doesn't exist
        }

        await client.createOrUpdateFile(
          owner,
          repo,
          doc.path,
          doc.content,
          `docs: ${doc.action} ${doc.path}\n\nGenerated by DocSynth from PR #${generationJob.changeAnalysis.prEvent.prNumber}`,
          docBranch,
          existingSha
        );
      }

      await job.updateProgress(80);

      // Create pull request
      const prBody = `## ðŸ“š Documentation Update

This PR was automatically generated by DocSynth based on changes in #${generationJob.changeAnalysis.prEvent.prNumber}.

### Documents ${result.documents.some((d) => d.action === 'create') ? 'Created' : 'Updated'}

${result.documents.map((d) => `- \`${d.path}\` (${d.action})`).join('\n')}

### Generation Metrics
- Tokens used: ${result.metrics.totalTokensUsed}
- Documents: ${result.metrics.documentsGenerated}

---
*Generated by [DocSynth](https://github.com/docsynth/docsynth) â€¢ [Review the changes](../../compare/${repository.defaultBranch}...${docBranch})*`;

      const pr = await client.createPullRequest(
        owner,
        repo,
        `ðŸ“š docs: Update documentation for PR #${generationJob.changeAnalysis.prEvent.prNumber}`,
        prBody,
        docBranch,
        repository.defaultBranch
      );

      // Add labels
      try {
        await client.addLabels(owner, repo, pr.number, ['documentation', 'docsynth']);
      } catch {
        // Labels might not exist, that's ok
      }

      await job.updateProgress(95);

      // Update generation job as completed
      await prisma.generationJob.update({
        where: { id: data.generationJobId },
        data: {
          status: 'COMPLETED',
          completedAt: new Date(),
          result: {
            ...result,
            prNumber: pr.number,
            prUrl: pr.url,
          },
        },
      });

      // Record usage
      const currentPeriod = new Date().toISOString().slice(0, 7); // YYYY-MM
      await prisma.usageRecord.upsert({
        where: {
          organizationId_repositoryId_period: {
            organizationId: repository.organizationId,
            repositoryId: repository.id,
            period: currentPeriod,
          },
        },
        create: {
          organizationId: repository.organizationId,
          repositoryId: repository.id,
          period: currentPeriod,
          generationsCount: 1,
          tokensUsed: result.metrics.totalTokensUsed,
        },
        update: {
          generationsCount: { increment: 1 },
          tokensUsed: { increment: result.metrics.totalTokensUsed },
        },
      });

      log.info(
        { generationJobId: data.generationJobId, prNumber: pr.number, prUrl: pr.url },
        'Documentation PR created'
      );

      await job.updateProgress(100);
    },
    { concurrency: 2 }
  );

  log.info('Doc review worker started');

  return worker;
}
