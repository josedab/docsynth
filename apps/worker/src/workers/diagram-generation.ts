import { Worker, Job } from 'bullmq';
import { prisma } from '@docsynth/database';
import { QUEUE_NAMES, getRedisConnection, type DiagramGenerationJobData } from '@docsynth/queue';
import { createLogger } from '@docsynth/utils';
import { DiagramGeneratorService } from '../services/diagram-generator.js';

const log = createLogger('diagram-generation-worker');

// Type assertion for new Prisma models
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const db = prisma as any;

const diagramGenerator = new DiagramGeneratorService();

async function processDiagramGeneration(job: Job<DiagramGenerationJobData>): Promise<void> {
  const { repositoryId, diagramType, format, scope, diagramId } = job.data;

  log.info({ repositoryId, diagramType, format }, 'Starting diagram generation');

  try {
    await job.updateProgress(10);

    // Get repository info
    const repository = await prisma.repository.findUnique({
      where: { id: repositoryId },
    });

    if (!repository) {
      throw new Error(`Repository not found: ${repositoryId}`);
    }

    // Get repository documents/code for analysis
    const documents = await prisma.document.findMany({
      where: { repositoryId },
      select: { path: true, content: true },
    });

    const files = documents
      .filter((d): d is typeof d & { content: string } => d.content !== null)
      .map((d) => ({ path: d.path, content: d.content }));

    if (files.length === 0) {
      throw new Error('No files found for diagram generation');
    }

    await job.updateProgress(30);

    // Generate diagram based on type
    let result;
    const combinedContent = files.map((f) => f.content).join('\n\n');
    
    switch (diagramType) {
      case 'architecture':
        result = await diagramGenerator.generateArchitectureDiagram(files, repository.name);
        break;
      case 'sequence':
        result = await diagramGenerator.generateSequenceDiagram(combinedContent, 'Main flow');
        break;
      case 'flowchart':
        result = await diagramGenerator.generateFlowchart(combinedContent, 'Process flow');
        break;
      case 'class':
        result = await diagramGenerator.generateClassDiagram(files.map((f) => f.content), repository.name);
        break;
      case 'entity-relationship':
        result = await diagramGenerator.generateERDiagram(combinedContent, repository.name);
        break;
      default:
        result = await diagramGenerator.generateArchitectureDiagram(files, repository.name);
    }

    await job.updateProgress(80);

    // Save or update diagram (using db for new models)
    if (diagramId) {
      await db.architectureDiagram.update({
        where: { id: diagramId },
        data: {
          source: result.mermaidCode,
          description: result.description,
          lastSyncedAt: new Date(),
          metadata: { title: result.title, type: result.type },
        },
      });
    } else {
      await db.architectureDiagram.create({
        data: {
          repositoryId,
          name: result.title,
          diagramType: result.type,
          format: format || 'mermaid',
          source: result.mermaidCode,
          description: result.description,
          autoGenerated: true,
          lastSyncedAt: new Date(),
          metadata: { scope: scope || [] },
        },
      });
    }

    await job.updateProgress(100);

    log.info(
      { repositoryId, diagramType, title: result.title },
      'Diagram generation completed'
    );
  } catch (error) {
    log.error({ error, repositoryId, diagramType }, 'Diagram generation failed');
    throw error;
  }
}

export function startDiagramGenerationWorker(): Worker<DiagramGenerationJobData> {
  const worker = new Worker<DiagramGenerationJobData>(
    QUEUE_NAMES.DIAGRAM_GENERATION,
    processDiagramGeneration,
    {
      connection: getRedisConnection(),
      concurrency: 2,
    }
  );

  worker.on('completed', (job) => {
    log.info({ jobId: job.id }, 'Diagram generation job completed');
  });

  worker.on('failed', (job, error) => {
    log.error({ jobId: job?.id, error: error.message }, 'Diagram generation job failed');
  });

  log.info('Diagram generation worker started');
  return worker;
}
